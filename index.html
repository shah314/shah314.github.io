<!DOCTYPE html>
<HTML><HEAD><TITLE>Shalin Shah Home Page</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
</HEAD>
<BODY>
<DIV align="center">
<h2 align="left"> Shalin Shah</h2></DIV>
<i>AI Scientist at Target Corporation</i><br>
<div align="left"><p align="left"><a href="http://shah.freeshell.org/contact/">Contact</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://shah.freeshell.org/about/">About Me</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="https://orcid.org/0000-0002-3770-1391">ORCID</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="https://github.com/shah314">GitHub</a></div>
<HR noShade SIZE=1>
<h4>Articles:</h4>
<ul>
<li><a href="https://joss.theoj.org/papers/10.21105/joss.01843">JCOL: A Java package for solving the graph coloring problem</a><br>
  The graph coloring problem aims at assigning colors to the nodes of a graph such that no two connected nodes have the same color. The graph coloring problem is NP-complete and one of the harder problems to solve. Here we present a heuristic to solve this problem using three randomized cascaded algorithms. The graph coloring problem was one of Karp’s 21 NP-complete problems, and is also know as the problem of finding the chromatic number of a graph. Several other problems reduce to graph coloring including solving generalized Sudoku puzzles.
</li><br>
<li><a href="https://arxiv.org/abs/2003.11916">Analysis of Greenhouse Gases</a><br>
  Climate change is a result of a complex system of interactions of greenhouse gases (GHG), the ocean, land, ice, and clouds. Large climate change models use several computers and solve several equations to predict the future climate. The equations may include simple polynomials to partial differential equations. Because of the uptake mechanism of the land and ocean, greenhouse gas emissions can take a while to affect the climate. The IPCC has published reports on how greenhouse gas emissions may affect the average temperature of the troposphere and the predictions show that by the end of the century, we can expect a temperature increase from 0.8 C to 5 C. In this article, I use Linear Regression (LM), Quadratic Regression and Gaussian Process Regression (GPR) on monthly GHG data going back several years and try to predict the temperature anomalies based on extrapolation. The results are quite similar to the IPCC reports.
</li><br>
<li><a href="https://joss.theoj.org/papers/10.21105/joss.01756">GKNAP: A Java and C++ package for solving the multidimensional knapsack problem</a>
  The 0/1 multidimensional (multi-constraint) knapsack problem is the 0/1 knapsack problem with m constraints. It is a strongly NP-hard problem, and might be difficult to solve using exact methods like branch and bound and dynamic programming, especially when the number of variables is large. We present a genetic algorithm for the multidimensional knapsack problem with Java and C++ code that is able to solve publicly available instances in a very short computational duration. Our algorithm uses iteratively computed Lagrangian multipliers as constraint weights to augment the greedy algorithm for the multidimensional knapsack problem and uses that information in a greedy crossover in a genetic algorithm. The algorithm uses several other hyperparameters which can be set in the code to control convergence. Our algorithm improves upon the algorithm by Chu and Beasley (Chu & Beasley, 1998) in that it converges to optimum or near optimum solutions much faster.
</li><br>
<li><a href="https://arxiv.org/abs/1908.08037">Hebbian Graph Embeddings</a><br>
  Representation learning has recently been successfully used to create vector representations of entities in language learning, recommender systems and in similarity learning. Graph embeddings exploit the locality structure of a graph and generate embeddings for nodes which could be words in a language, products of a retail website; and the nodes are connected based on a context window. In this paper, we consider graph embeddings with an error-free associative learning update rule, which models the embedding vector of node as a non-convex Gaussian mixture of the embeddings of the nodes in its immediate vicinity with some constant variance that is reduced as iterations progress. It is very easy to parallelize our algorithm without any form of shared memory, which makes it possible to use it on very large graphs with a much higher dimensionality of the embeddings. We study the efficacy of proposed method on several benchmark data sets and favorably compare with state of the art methods. Further, proposed method is applied to generate relevant recommendations for a large retailer.
</li><br>
<li><a href="https://arxiv.org/abs/1908.08022">Genetic Algorithm for the 0/1 Multidimensional Knapsack Problem</a><br>
  The 0/1 multidimensional knapsack problem is the 0/1 knapsack problem with m constraints which makes it difficult to solve using traditional methods like dynamic programming or branch and bound algorithms. We present a genetic algorithm for the multidimensional knapsack problem with Java and C++ code that is able to solve publicly available instances in a very short computational duration. Our algorithm uses iteratively computed Lagrangian multipliers as constraint weights to augment the greedy algorithm for the multidimensional knapsack problem and uses that information in a greedy crossover in a genetic algorithm. The algorithm uses several other hyperparameters which can be set in the code to control convergence. Our algorithm improves upon the algorithm by Chu and Beasley in that it converges to optimum or near optimum solutions much faster.
</li><br>
<li><a href="https://zenodo.org/record/3344938">Introduction to Matrix Factorization for Recommender Systems</a><br>
  Recommender systems aim to personalize the experience of user by suggesting items to the user based on the preferences of a user. The preferences are learned from the user’s interaction history or through explicit ratings that the user has given to the items. The system could be part of a retail website, an online bookstore, a movie rental service or an online education portal and so on. In this paper, I will focus on matrix factorization algorithms as applied to recommender systems and discuss the singular value decomposition, gradient descent-based matrix factorization and parallelizing matrix factorization for large scale applications.
</li><br>
<li><a href="https://arxiv.org/abs/1903.03494">Genetic Algorithm for a class of Knapsack Problems</a><br>
  The 0/1 knapsack problem is weakly NP-hard in that there exist pseudo-polynomial time algorithms based on dynamic programming that can solve it exactly. There are also the core branch and bound algorithms that can solve large randomly generated instances in a very short amount of time. However, as the correlation between the variables is increased, the difficulty of the problem increases. Recently a new class of knapsack problems was introduced by D. Pisinger called the spanner knapsack instances. These instances are unsolvable by the core branch and bound instances; and as the size of the coefficients and the capacity constraint increase, the spanner instances are unsolvable even by dynamic programming based algorithms. In this paper, a genetic algorithm is presented for spanner knapsack instances. Results show that the algorithm is capable of delivering optimum solutions within a reasonable amount of computational duration.
</li><br>
<li><a href="https://www.microsoft.com/en-us/research/publication/model-adaptation-via-model-interpolation-and-boosting-for-web-search-ranking/">Model Adaptation via Model Interpolation and Boosting for Web Search Ranking</a><br>
  This paper explores two classes of model adaptation methods for Web search ranking: Model Interpolation and error-driven learning approaches based on a boosting algorithm. The results show that model interpolation, though simple, achieves the best results on all the open test sets where the test data is very different from the training data. The tree-based boosting algorithm achieves the best performance on most of the closed test sets where the test data and the training data are similar, but its performance drops significantly on the open test sets due to the instability of trees. Several methods are explored to improve the robustness of the algorithm, with limited success.
</li><br>
<li><a href="https://patents.google.com/patent/US20190149626A1/en">Similarity learning-based device attribution</a><br>
  Methods and systems for attributing browsing activity from two or more different network-connected devices (cross-device) to a single user are disclosed. In one aspect, cookies generated by the browsing activity of different unidentified devices at a website are received. A random forest classifier trained on probabilities output from a Gaussian mixture model is applied to the unidentified cookies to determine a probability that two different cookies were generated by the same user. In some embodiments, personalized content is then delivered to the user based on the characteristics of the paired cookies.
</li><br>
<li><a href="https://www.researchgate.net/publication/340315388_Parallel_Taxonomy_Discovery">Parallel Taxonomy Discovery</a><br>
  Recommender systems aim to personalize the shopping experience of a user by suggesting related products, or products that are found to be in the general interests of the user. The information available for users and products is heterogenous, and many systems use one or some of the information. The information available include the user's interactions history with the products and categories, textual information of the products, a hierarchical classification of the products into a taxonomy, user interests based on a questionnaire, the demographics of a user, inferred interests based on product reviews given by a user, interests based on the physical location of a user and so on. Taxonomy discovery for personalized recommendation is work published in 2014 which uses the first three information sources-the user's interaction history, textual information of the products and optionally, an existing taxonomy of the products. In this paper, we describe a parallel implementation of this approach on Apache Spark and discuss the modifications to the algorithm in order to scale it to several hundreds of thousands of users with a large inventory of products at Target corporation. We run experiments on a sample of users and provide results including some sample recommendations generated by our parallel algorithm.
</li><br>
<li><a href="https://www.researchgate.net/publication/340315298_Notes_on_Icebreaker">Notes on Icebreaker</a><br>
  Icebreaker is new research from Microsoft Research that is able to achieve state of the art performance on inference in which there is inherent missing data. Using mutual information, Icebreaker is able to suggest which values in the data to impute for maximum benefit. These notes are an amalgamation of information from various articles and tutorials including auto-encoders, variational inference, variational auto-encoders, the evidence lower bound, set based learning and finally leading to Icebreaker. References are provided whenever appropriate. There may be factual errors and typos in these notes. Please send them to the author.
</li><br>
<li><a href="https://www.researchgate.net/publication/340315429_Analysis_of_E-Commerce_Product_Graphs">Analysis of E-Commerce Product Graphs</a><br>
  Consumer behavior in retail stores gives rise to product graphs based on co-purchasing or co-viewing behavior. These product graphs can be analyzed using the known methods of graph analysis. In this paper, we analyze the product graph at Target Corporation based on the Erdos-Renyi random graph model. In particular, we compute clustering coefficients of actual and random graphs, and we find that the clustering coefficients of actual graphs are much higher than random graphs. We conduct the analysis on the entire set of products and also on a per category basis and find interesting results. We also compute the degree distribution and we find that the degree distribution is a power law as expected from real world networks, contrasting with the ER random graph. We also find that product graphs also exhibit the small world property (six degrees of separation) that social networks exhibit.
</li><br>
</ul>
<H4><B>Code:</B></H4>
<UL>
<li><a href="https://github.com/shah314/clique2/">Randomized Heuristic for the Maximum Clique Problem</a> (Java)<br>
  A simple random search algorithm for the maximum clique problem. A clique of a graph is a set of vertices in which each pair in the set have an edge between them i.e. it is a complete subgraph. A clique of maximum size is called the maximum clique. Finding the maximum clique of a graph is an NP-complete problem, and it it not possible to approximate the problem within a constant factor of the optimal.
</li><br>
<li><a href="http://shah.freeshell.org/clique/">Genetic Algorithm for the Maximum Clique Problem</a> (C++)<br>
  Implementation of a genetic algorithm for the maximum clique problem in C++. A clique of a graph is a set of vertices in which each pair in the set have an edge between them i.e. it is a complete subgraph. A clique of maximum size is called the maximum clique. The algorithm uses new types of crossovers to achieve good results on several public graph datasets.
</li><br>
<LI><A href="http://shah.freeshell.org/gamultiknapsack/">Genetic Algorithm - 0/1 Multi-Constraint Knapsack Problem</A> (C++ and Java)<br>
  A genetic algorithm implementation for the multidimensional knapsack problem. The multi-constraint (or multidimensional) knapsack problem is a generalization of the 0/1 knapsack problem. The multi-constraint knapsack problem has m constraints and one objective function to be maximized while all the m constraints are satisfied. The implementation is similar to the one described in [Chu98], but its significantly different. It uses Lagrangian multipliers as constraint weights and compared to the paper, it finds close to optimum solutions much faster. (Convergence can be controlled using the parameters).
</li><br>
<li><a href="http://shah.freeshell.org/graphcoloring/">Heuristic for Graph Coloring</a> (Java)<br>
  Implementation of the DSatur, Randomized Iterated Greedy and Min-Conflicts Local Search heuristics for graph coloring in Java. The algorithm is created with tha aim of obtaining the best coloring, irrespective of run time. If you need to speed up the algorithm, consider not using local search. Also, if you need help with this, please open an issue.
</li><br>
<LI><A href="http://shah.freeshell.org/sudoku/">Sudoku Solvers and Puzzle Generator</A> (C++ and Java)<br>
  Sudoku is a Japanese puzzle in which a 9x9 grid is partially filled with numbers from 1 to 9. A solution to this puzzle fills in the empty cells of the grid such that there are no repeating numbers in each row, each column and each 3x3 subgrid. The general Sudoku problem is NP-Complete (by reduction from graph coloring). It is not difficult to adapt the code to generate puzzles larger than the 3x3 subgrid. The code solves Sudoku using backtracking. There is also a puzzle generator which generates Sudoku puzzles which have unique solutions.
</li><br>
<LI><A href="http://shah.freeshell.org/samultichoiceknapsack/">Simulated Annealing Algorithm - Multiple Choice Multidimensional knapsack problem</A>  (C++)<br>
  Implementation of simulated annealing algorithm for the multiple choice multidimensional knapsack problem. The multiple choice knapsack problem has n groups of items and m constraints. The objective is to choose one item from each group such that the total value (profit) is maximized while all of the m constraints are satisfied.
</li><br>
<LI><A href="http://shah.freeshell.org/ilsassignment/">Iterative Local Search - Quadratic Assignment Problem</A> (C++)<br>
  Implementation of iterative local search for the quadratic assignment problem (C++). The QAP is a strongly NP-hard problem, and solving instances with more than 20 variables is considered intractable. The implementation uses a population of individuals and performs local improvement on them. Local improvement accepts worse solutions with a probability of 0.0. The parameters of the algorithm can be adjusted by changing the global variables. The algorithm can be used to find approximate solutions for large QAP instances for which exact methods are not suitable. (The code finds optimal solutions to all nugXX instances in a few seconds)
</li><br>
<li><a href="https://github.com/shah314/knapsack/">Branch and Bound Algorithm for the 0/1 Knapsack Problem</a> (Java)
  A Java implementation of the branch and bound algorithm for the 0/1 knapsack problem. The code uses Lagrangian relaxation to prune the search tree. It uses best first search. A sample instance of 5000 items is included. This instance has the weights in weights.txt and values (profits) in values.txt. The file solution.txt contains some information about the problem instance. The algorithm takes about 50 seconds to solve the 5000 instance (depends on the constraint though).
</li><br>
<LI><A href="http://shah.freeshell.org/montyhall/">Monty Hall Simulation</A> (Java)<br>
  The Monty Hall paradox is a classic problem in probability theory where Monty, a game show host shows three doors to a player. Behind one of the three doors is a car, and behind the rest of the two doors is nothing. The player first chooses any one of the three doors but does not open it. Then, Monty opens one of the remaining doors that is non-winning. The player is then given an option to switch to the remaining unopened door, or stick to the door that he chose in the beginning of the game. The argument is that it is a good strategy for the player to switch.
</LI><br>
</UL>
<HR noShade SIZE=1>
<p align="center"><I>shah DOT shalin AT gmail DOT com</I></p>
</DIV></BODY></HTML>
